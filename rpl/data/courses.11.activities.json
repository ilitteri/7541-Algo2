[
	{
		"id": 328,
		"course_id": 11,
		"category_id": 70,
		"category_name": "F - Grafos: Usos, implementaciones, recorridos",
		"category_description": "Ejercicios para saber manejarse entre distintos tipos de grafos de distintas formas",
		"name": "00 - Ciclo en grafo no dirigido",
		"description": "## Consigna\nImplementar un algoritmo que, dado un grafo no dirigido, nos devuelva un ciclo dentro del mismo, si es que los tiene. Indicar el orden del algoritmo.\n\n## Ejemplo\n- Para el grafo {A: [B], B: [A, C], C: [B]} el resultado ser\u00eda lista vac\u00eda: []\n- Para el grafo {A: [B, C], B: [A, C], C: [B,A]} el resultado podr\u00eda ser, entre otros, [A,B,C] ya que existe un camino que recorra A -> B -> C -> A\n\n\n### M\u00e9todos del grafo no dirigido:\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": true,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9773,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 329,
		"course_id": 11,
		"category_id": 70,
		"category_name": "F - Grafos: Usos, implementaciones, recorridos",
		"category_description": "Ejercicios para saber manejarse entre distintos tipos de grafos de distintas formas",
		"name": "03 - Grado de vertices",
		"description": "Implementar una funci\u00f3n que determine el:\n\na. El grado de todos los v\u00e9rtices de un grafo no dirigido.\n\nb. El grado de salida de todos los v\u00e9rtices de un grafo dirigido.\n\nc. El grado de entrada de todos los v\u00e9rtices de un grafo dirigido.\n\nNota: Las funciones deberan devolver un diccionario con clave vertice y valor grado.\n\n### M\u00e9todos del grafo:\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9774,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 330,
		"course_id": 11,
		"category_id": 70,
		"category_name": "F - Grafos: Usos, implementaciones, recorridos",
		"category_description": "Ejercicios para saber manejarse entre distintos tipos de grafos de distintas formas",
		"name": "04 - Es conexo",
		"description": "Implementar un algoritmo que determine si un grafo no dirigido es conexo o no. Indicar la complejidad del algoritmo si el grafo est\u00e1 implementado con una matriz de adyacencia.\n\n### M\u00e9todos del grafo no dirigido:\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9776,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 331,
		"course_id": 11,
		"category_id": 70,
		"category_name": "F - Grafos: Usos, implementaciones, recorridos",
		"category_description": "Ejercicios para saber manejarse entre distintos tipos de grafos de distintas formas",
		"name": "10 - Es bipartito",
		"description": "Escribir una funci\u00f3n bool `es_bipartito(grafo)` que dado un grafo no dirigido devuelva `true` o `false` de acuerdo a si es bipartito o no. Indicar y justificar el orden del algoritmo. \u00bfQu\u00e9 tipo de recorrido utiliza?\n\n### M\u00e9todos del grafo no dirigido:\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9778,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 332,
		"course_id": 11,
		"category_id": 70,
		"category_name": "F - Grafos: Usos, implementaciones, recorridos",
		"category_description": "Ejercicios para saber manejarse entre distintos tipos de grafos de distintas formas",
		"name": "15 - Libro multi tramas",
		"description": "Un autor decidi\u00f3 escribir un libro con varias tramas que se puede leer de forma no lineal. Es decir, por ejemplo, despu\u00e9s del cap\u00edtulo 1 puede leer el 2 o el 73; pero la historia no tiene sentido si se abordan estos \u00faltimos antes que el 1.\n\nSiendo un aficionado de la computaci\u00f3n, el autor ahora necesita un orden para publicar su obra, y decidi\u00f3 modelar este problema como un grafo dirigido, en d\u00f3nde los cap\u00edtulos son los v\u00e9rtices y sus dependencias las aristas. As\u00ed existen, por ejemplo, las aristas (v1, v2) y (v1, v73).\n\nEscribir un algoritmo que devuelva un orden en el que se puede leer la historia sin obviar ning\u00fan cap\u00edtulo. Indicar la complejidad del algoritmo.\n\n### M\u00e9todos del grafo:\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 4,
		"file_id": 9780,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 333,
		"course_id": 11,
		"category_id": 71,
		"category_name": "G - Grafos: Aplicaciones y Algoritmos",
		"category_description": "",
		"name": "00 - Diametro de grafo",
		"description": "El di\u00e1metro de una red es el m\u00e1ximo de las distancias m\u00ednimas entre todos los v\u00e9rtices de la misma. Implementar un algoritmo que permita obtener el di\u00e1metro de una red, para el caso de un grafo no dirigido y no pesado. Indicar el orden del algoritmo propuesto.\n\n### M\u00e9todos del grafo:\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9782,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 334,
		"course_id": 11,
		"category_id": 71,
		"category_name": "G - Grafos: Aplicaciones y Algoritmos",
		"category_description": "",
		"name": "09 - Coloreo de grafos",
		"description": "Implementar un algoritmo que reciba un grafo y un n\u00famero nn que, utilizando backtracking, indique si es posible pintar cada v\u00e9rtice con nn colores de tal forma que no hayan dos v\u00e9rtices adyacentes con el mismo color.\n\n### M\u00e9todos del grafo\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 4,
		"file_id": 9784,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 335,
		"course_id": 11,
		"category_id": 72,
		"category_name": "Uso de la plataforma RPL",
		"category_description": "Dos ejercicios f\u00e1ciles para que prueben la plataforma",
		"name": "Ejercicio con test unitarios",
		"description": "\nImplementar la funci\u00f3n `es_par`",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9786,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-10-12T23:04:33Z",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 336,
		"course_id": 11,
		"category_id": 72,
		"category_name": "Uso de la plataforma RPL",
		"category_description": "Dos ejercicios f\u00e1ciles para que prueben la plataforma",
		"name": "Ejercicio con tests de entrada salida",
		"description": "# Enunciado\n\nImplementar un programa que reciba por stdin un n\u00famero e imprima su doble",
		"language": "PYTHON3",
		"is_iotested": true,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9788,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-10-17T23:05:26Z",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 337,
		"course_id": 11,
		"category_id": 71,
		"category_name": "G - Grafos: Aplicaciones y Algoritmos",
		"category_description": "",
		"name": "10 - Problema del viajante",
		"description": "Problema del viajante (TSP): Dada una lista de ciudades y la distancia entre cada par de ellas, \u00bfCu\u00e1l es el peso de la ruta m\u00e1s corta posible que visita cada ciudad exactamente una vez y al finalizar regresa a la ciudad de origen?\n\n### M\u00e9todos del grafo\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 8,
		"file_id": 9789,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 338,
		"course_id": 11,
		"category_id": 71,
		"category_name": "G - Grafos: Aplicaciones y Algoritmos",
		"category_description": "",
		"name": "13 - Cantidad minima de inversiones",
		"description": "Implementar un algoritmo que, dado un grafo dirigido, un v\u00e9rtice _s_ y otro _t_ determine la cantidad m\u00ednima de aristas que deber\u00edan cambiar de sentido en el grafo para que exista un camino de _s_ a _t_.\n\n### M\u00e9todos del grafo\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 16,
		"file_id": 9791,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 339,
		"course_id": 11,
		"category_id": 71,
		"category_name": "G - Grafos: Aplicaciones y Algoritmos",
		"category_description": "",
		"name": "08 - N vertices no adyacentes",
		"description": "Implementar por backtracking un algoritmo que, dado un grafo no dirigido y un numero n menor a #V, devuelva si es posible obtener un subconjunto de n vertices tal que ningun par de vertices sea adyacente entre si. \n\nSe puede suponer que los v\u00e9rtices est\u00e1n identificados con n\u00fameros de 0 a V - 1.\n\n### M\u00e9todos del grafo\n- agregar_vertice(self, v)\n- borrar_vertice(self, v)\n- agregar_arista(self, v, w, peso = 1)\n    - el resultado ser\u00e1  `v <--> w`\n- borrar_arista(self, v, w)\n- estan_unidos(self, v, w)\n- peso_arista(self, v, w)\n- obtener_vertices(self)\n    - Devuelve una lista con todos los v\u00e9rtices del grafo\n- vertice_aleatorio(self)\n- adyacentes(self, v)\n- __str__",
		"language": "PYTHON3",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 10,
		"file_id": 9793,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 340,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "01 - TDA Fraccion",
		"description": "Implementar el TDA Fracci\u00f3n. Dicho TDA debe tener las siguientes primitivas, cuya documentaci\u00f3n puede encontrarse en `fraccion.h`:\n\n```\nfraccion_t* fraccion_crear(int numerador, int denominador);\nfraccion_t* fraccion_sumar(fraccion_t* f1, fraccion_t* f2);\nfraccion_t* fraccion_mul(fraccion_t* f1, fraccion_t* f2);\nchar* fraccion_representacion(fraccion_t* fraccion);\nint fraccion_parte_entera(fraccion_t* fraccion);\nvoid fraccion_destruir(fraccion_t* fraccion);\n```\n\nNota: considerar que se puede utilizar la funci\u00f3n sprintf para generar la representaci\u00f3n de la fracci\u00f3n. Por ejemplo: sprintf(buffer, \"%d/%d\", num1, num2).",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9795,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-01T20:08:27Z",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 341,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "05 - Composicion de funciones",
		"description": "Implementar en C el TDA Composici\u00f3nFunciones que emula la composici\u00f3n de funciones (i.e. f(g(h(x))). Se debe definir la estructura del TDA, y las siguientes primitivas:\n```\ncomposicion_t* composicion_crear();\nvoid composicion_destruir(composicion_t*);\nbool composicion_agregar_funcion(composicion_t*, double (*f)(double));\ndouble composicion_aplicar(composicion_t*, double);\n```\n\nConsiderar que primero se ir\u00e1n agregando las funciones como se leen, pero tener en cuenta el correcto orden de aplicaci\u00f3n. Por ejemplo: para emular f(g(x)), se debe hacer:\n\n```\ncomposicion_agregar_funcion(composicion, f);\ncomposicion_agregar_funcion(composicion, g);\ncomposicion_aplicar(composicion, x);\n```\n\nIndicar el orden de las primitivas.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9797,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-02T15:11:24Z",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-04T17:18:44Z"
	},
	{
		"id": 342,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "06 - Lista ante k \u00faltimo",
		"description": "Dada una lista enlazada implementada con las siguientes estructuras:\n\n```\ntypedef struct nodo {\n    void *dato;\n    struct nodo *prox;\n} nodo_t;\n\nstruct lista {\n    nodo_t *primero;\n};\n```\n\nEscribir una primitiva que reciba una lista y devuelva el elemento que est\u00e9 a _k_ posiciones del final (el ante-k-\u00faltimo), recorriendo la lista una sola vez y sin usar estructuras auxiliares. Considerar que _k_ es siempre menor al largo de la lista. Por ejemplo, si se recibe la lista [ 1, 5, 10, 3, 6, 8 ], y k = 4, debe devolver 10. Indicar el orden de complejidad de la primitiva.\n\n",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 4,
		"file_id": 9799,
		"submission_status": "TIME_OUT",
		"last_submission_date": "2020-10-26T23:22:16Z",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-10-29T19:19:24Z"
	},
	{
		"id": 343,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "10 - Invertir lista",
		"description": "Implementar en C una primitiva `void lista_invertir(lista_t* lista)` que invierta la lista recibida por par\u00e1metro, sin utilizar estructuras auxiliares. Indicar y justificar el orden de la primitiva.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9801,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-01T19:10:06Z",
		"date_created": "2020-10-04T17:18:44Z",
		"last_updated": "2020-11-01T01:08:56Z"
	},
	{
		"id": 344,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "07 - Pila piramidal (ordenada ascendente)",
		"description": "Dada una pila de enteros, escribir una funci\u00f3n que determine si es piramidal. Una pila de enteros es piramidal si cada elemento es menor a su elemento inferior (en el sentido que va desde el tope de la pila hacia el otro extremo). La pila no debe ser modificada.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 4,
		"file_id": 9803,
		"submission_status": "TIME_OUT",
		"last_submission_date": "2020-10-31T19:12:40Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-27T22:41:52Z"
	},
	{
		"id": 345,
		"course_id": 11,
		"category_id": 74,
		"category_name": "B - Division y Conquista",
		"category_description": "",
		"name": "00 - Arreglo m\u00e1gico",
		"description": "Implementar un algoritmo en C que reciba un arreglo de enteros de tama\u00f1o nn, ordenado ascendentemente y sin elementos repetidos, y determine en _O(log n)_ si es m\u00e1gico. Un arreglo es m\u00e1gico si existe alg\u00fan valor _i_ tal que 0 <= i y `arr[i] = i`. Justificar el orden del algoritmo.\n\nEjemplos:\n\nA = [ -3, 0, 1, 3, 7, 9 ] es m\u00e1gico porque A[3] = 3.\n\nB = [ 1, 2, 4, 6, 7, 9 ] no es m\u00e1gico porque B[i] != i para todo i.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9805,
		"submission_status": "TIME_OUT",
		"last_submission_date": "2020-10-31T16:23:05Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-22T20:44:19Z"
	},
	{
		"id": 346,
		"course_id": 11,
		"category_id": 74,
		"category_name": "B - Division y Conquista",
		"category_description": "",
		"name": "12 - Raiz cuadrada",
		"description": "Implementar un algoritmo que, por divisi\u00f3n y conquista, permita obtener la parte entera de la ra\u00edz cuadrada de un n\u00famero _n_, en tiempo _O(log n)_. Por ejemplo, para n = 10 debe devolver 3, y para n = 25 debe devolver 5.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 8,
		"file_id": 9807,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-10-17T23:04:11Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-22T00:18:55Z"
	},
	{
		"id": 347,
		"course_id": 11,
		"category_id": 74,
		"category_name": "B - Division y Conquista",
		"category_description": "",
		"name": "17 - Mas de la mitad de repeticiones",
		"description": "Implementar una funci\u00f3n (que utilice divisi\u00f3n y conquista) de orden _O(n logn)_ que dado un arreglo de _n_ n\u00fameros enteros devuelva true o false seg\u00fan si existe alg\u00fan elemento que aparezca m\u00e1s de la mitad de las veces. Justificar el orden de la soluci\u00f3n. Ejemplos:\n\n```\n[1, 2, 1, 2, 3] -> false\n[1, 1, 2, 3] -> false\n[1, 2, 3, 1, 1, 1] -> true\n[1] -> true\n```\n\nAclaraci\u00f3n: Este ejercicio puede resolverse, casi trivialmente, ordenando el arreglo con un algoritmo eficiente, o incluso se puede realizar m\u00e1s r\u00e1pido utilizando una tabla de hash. Para hacer interesante el ejercicio, resolver sin ordenar el arreglo, sino puramente divisi\u00f3n y conquista.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 16,
		"file_id": 9809,
		"submission_status": "TIME_OUT",
		"last_submission_date": "2020-11-01T21:34:03Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-04T18:59:46Z"
	},
	{
		"id": 348,
		"course_id": 11,
		"category_id": 75,
		"category_name": "C - Diccionarios, Hashing y Hash",
		"category_description": "",
		"name": "00.a - Hash claves (Cerrado)",
		"description": "Para un hash cerrado, implementar una primitiva `lista_t* hash_claves(const hash_t*)` que reciba un hash y devuelva una lista con sus claves.\n\n",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9811,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-11-23T22:19:01Z"
	},
	{
		"id": 349,
		"course_id": 11,
		"category_id": 75,
		"category_name": "C - Diccionarios, Hashing y Hash",
		"category_description": "",
		"name": "00.b - Hash claves (Abierto)",
		"description": "Para un hash abierto, implementar una primitiva `lista_t* hash_claves(const hash_t*)` que reciba un hash y devuelva una lista con sus claves.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9813,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-11-23T22:18:39Z"
	},
	{
		"id": 350,
		"course_id": 11,
		"category_id": 75,
		"category_name": "C - Diccionarios, Hashing y Hash",
		"category_description": "",
		"name": "00.c - Hash claves (Funci\u00f3n)",
		"description": "Implementar una funci\u00f3n `lista_t* hash_claves(const hash_t*)` que reciba un hash y devuelva una lista con sus claves.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9815,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-12T13:48:46Z"
	},
	{
		"id": 351,
		"course_id": 11,
		"category_id": 75,
		"category_name": "C - Diccionarios, Hashing y Hash",
		"category_description": "",
		"name": "05 - Mas de la mitad de repeticiones",
		"description": "Implementar una funci\u00f3n de orden O(n) que dado un arreglo de n n\u00fameros enteros devuelva true o false seg\u00fan si existe alg\u00fan elemento que aparezca m\u00e1s de la mitad de las veces. Justificar el orden de la soluci\u00f3n. Ejemplos:\n\n```\n[1, 2, 1, 2, 3] -> false\n[1, 1, 2, 3] -> false\n[1, 2, 3, 1, 1, 1] -> true\n[1] -> true\n```",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9817,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-04T17:18:45Z"
	},
	{
		"id": 352,
		"course_id": 11,
		"category_id": 75,
		"category_name": "C - Diccionarios, Hashing y Hash",
		"category_description": "",
		"name": "06 - Son iguales",
		"description": "Asumiendo que se tiene disponible una implementaci\u00f3n completa del TDA Hash, se desea implementar una funci\u00f3n que decida si dos Hash dados representan o no el mismo Diccionario. Considere para la soluci\u00f3n que es de inter\u00e9s la mejor eficiencia temporal posible. Indique, para su soluci\u00f3n, eficiencia en tiempo y espacio. Nota: Dos tablas de hash representan el mismo diccionario si tienen la misma cantidad de elementos; todas las claves del primero est\u00e1n en el segundo; todas las del segundo, en el primero; y los datos asociados a cada una de esas claves son iguales (se pueden comparar los valores con \u201c==\u201d).",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9819,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-04T17:18:45Z"
	},
	{
		"id": 353,
		"course_id": 11,
		"category_id": 76,
		"category_name": "D - \u00c1rboles Binarios, ABB, AVL, \u00c1rbol B",
		"category_description": "",
		"name": "00 - Obtener mayores",
		"description": "Se tiene un \u00e1rbol binario de b\u00fasqueda con cadenas como claves y funci\u00f3n de comparaci\u00f3n strcmp. Implementar una primitiva `lista_t* abb_mayores(const abb_t* abb, const char* cadena)` que, dados un ABB y una cadena, devuelva una lista ordenada con las claves del \u00e1rbol estrictamente mayores a la cadena recibida por par\u00e1metro (que no necesariamente est\u00e1 en el \u00e1rbol).",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9821,
		"submission_status": "BUILD_ERROR",
		"last_submission_date": "2020-11-28T21:04:14Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-30T20:12:23Z"
	},
	{
		"id": 354,
		"course_id": 11,
		"category_id": 76,
		"category_name": "D - \u00c1rboles Binarios, ABB, AVL, \u00c1rbol B",
		"category_description": "",
		"name": "11 - Obtener claves",
		"description": "Implementar una primitiva para el ABB, que devuelva una lista con las claves del mismo, ordenadas tal que si insert\u00e1ramos las claves en un ABB vac\u00edo, dicho ABB tendr\u00eda la misma estructura que el \u00e1rbol original.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9823,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-28T21:26:43Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-11-15T23:42:51Z"
	},
	{
		"id": 355,
		"course_id": 11,
		"category_id": 77,
		"category_name": "E - Colas de Prioridad y Heaps",
		"category_description": "",
		"name": "00 - Cambiar Prioridad",
		"description": "Implementar en C una primitiva para el heap (siendo este un max-heap) que reciba un heap y una funci\u00f3n de comparaci\u00f3n y lo reordene de manera tal que se se comporte como max-heap para la nueva funci\u00f3n de comparaci\u00f3n (se cambia la funci\u00f3n de prioridad). El orden de dicha primitiva debe ser O(n).",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9825,
		"submission_status": "",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-04T17:18:45Z"
	},
	{
		"id": 364,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "03 - Invertir Arreglo",
		"description": "Implementar una funci\u00f3n que reciba un arreglo de `void*` e invierta su orden, utilizando los TDAs vistos. Indicar y justificar el orden de ejecuci\u00f3n.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 9843,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-01T20:16:32Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-28T15:27:05Z"
	},
	{
		"id": 365,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "08 - Cola Multiprimeros (primitiva)",
		"description": "Implementar la primitiva `void** cola_multiprimeros(const cola_t* cola, size_t k)` que dada una cola y un n\u00famero `k`, devuelva los primeros `k` elementos de la cola, en el mismo orden en el que habr\u00edan salido de la cola. En caso que la cola tenga menos de kk elementos, rellenar con `NULL`. Indicar y justificar el orden de ejecuci\u00f3n del algoritmo.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9845,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-10-31T20:28:28Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-30T17:58:51Z"
	},
	{
		"id": 366,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "09 - Cola Multiprimeros (funci\u00f3n)",
		"description": "Implementar la funci\u00f3n `void** cola_multiprimeros(cola_t* cola, size_t k)` que dada una cola y un n\u00famero `k`, devuelva los primeros `k` elementos de la cola, en el mismo orden en el que habr\u00edan salido de la cola. En caso que la cola tenga menos de kk elementos, rellenar con `NULL`. Indicar y justificar el orden de ejecuci\u00f3n del algoritmo.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9847,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-01T21:22:04Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-30T17:58:02Z"
	},
	{
		"id": 367,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "12 - Ordenar Pila",
		"description": "Implementar una funci\u00f3n que ordene de manera ascendente una pila de enteros sin conocer su estructura interna y utilizando como estructura auxiliar s\u00f3lo otra pila auxiliar. Por ejemplo, la pila `[ 4, 1, 5, 2, 3 ]` debe quedar como `[ 1, 2, 3, 4, 5 ]` (siendo el \u00faltimo elemento el tope de la pila, en ambos casos). Indicar y justificar el orden de la funci\u00f3n.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 8,
		"file_id": 9849,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-10-26T22:36:00Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-26T22:34:53Z"
	},
	{
		"id": 369,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "13 - Cola Filtrar",
		"description": "Implementar una funci\u00f3n void `void cola_filtrar(cola_t* cola, bool (*filtro)(void*))`, que elimine los elementos encolados para los cuales la funci\u00f3n filtro devuelve false. Aquellos elementos que no son eliminados deben permanecer en el mismo orden en el que estaban antes de invocar a la funci\u00f3n. No es necesario destruir los elementos que s\u00ed fueron eliminados. Se pueden utilizar las estructuras auxiliares que se consideren necesarias y no est\u00e1 permitido acceder a la estructura interna de la cola (es una funci\u00f3n). \u00bfCu\u00e1l es el orden del algoritmo implementado?",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9853,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-01T20:46:27Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-11-01T15:44:53Z"
	},
	{
		"id": 370,
		"course_id": 11,
		"category_id": 73,
		"category_name": "A - Concepto de TDAs, Pilas, Colas y Listas",
		"category_description": "Ejercicios b\u00e1sicos sobre los TDAs Pila, Cola y Lista enlazada",
		"name": "14 - Visitar para lista de n\u00fameros pares",
		"description": "Sabiendo que la firma del iterador interno de la lista enlazada es:\n```cpp\nvoid lista_iterar(lista_t* lista,\n                  bool (*visitar)(void* dato, void* extra),\n                  void* extra);\n```\nSe tiene una lista en donde todos los elementos son punteros a n\u00fameros enteros. Implementar la funci\u00f3n visitar para que calcule la suma de todos los n\u00fameros pares.\n\n",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 4,
		"file_id": 9855,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-02T02:19:28Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-11-01T15:49:03Z"
	},
	{
		"id": 371,
		"course_id": 11,
		"category_id": 74,
		"category_name": "B - Division y Conquista",
		"category_description": "",
		"name": "08 - Buscar m\u00ednimo",
		"description": "Implementar, por divisi\u00f3n y conquista, una funci\u00f3n que determine el m\u00ednimo de un arreglo. Indicar y justificar el orden.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9857,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-10-31T16:44:30Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-15T01:20:28Z"
	},
	{
		"id": 372,
		"course_id": 11,
		"category_id": 74,
		"category_name": "B - Division y Conquista",
		"category_description": "",
		"name": "09 - Arreglo ordenado",
		"description": "Implementar, por divisi\u00f3n y conquista, una funci\u00f3n que dado un arreglo y su largo, determine si el mismo se encuentra ordenado. Indicar y justificar el orden.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9859,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-10-31T17:26:21Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-04T18:57:45Z"
	},
	{
		"id": 373,
		"course_id": 11,
		"category_id": 74,
		"category_name": "B - Division y Conquista",
		"category_description": "",
		"name": "10 - Elemento desordenado",
		"description": "Implementar, por divisi\u00f3n y conquista, una funci\u00f3n que dado un arreglo sin elementos repetidos y casi ordenado (todos los elementos se encuentran ordenados, salvo uno), obtenga el elemento fuera de lugar. Indicar y justificar el orden.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 9861,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-10-31T17:10:05Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-27T21:16:36Z"
	},
	{
		"id": 374,
		"course_id": 11,
		"category_id": 74,
		"category_name": "B - Division y Conquista",
		"category_description": "",
		"name": "11 - unos y ceros",
		"description": "Se tiene un arreglo tal que [1, 1, 1, ..., 0, 0, ...] (es decir, unos seguidos de ceros). Se pide una funci\u00f3n de orden O(log(n)) que encuentre el \u00edndice del primer 0. Si no hay ning\u00fan 0 (solo hay unos), debe devolver -1.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 4,
		"file_id": 9863,
		"submission_status": "TIME_OUT",
		"last_submission_date": "2020-10-31T19:58:10Z",
		"date_created": "2020-10-04T17:18:45Z",
		"last_updated": "2020-10-04T18:58:11Z"
	},
	{
		"id": 375,
		"course_id": 11,
		"category_id": 74,
		"category_name": "B - Division y Conquista",
		"category_description": "",
		"name": "15 - Picos",
		"description": "Se tiene un arreglo de N >= 3 elementos en forma de pico, esto es: estrictamente creciente hasta una determinada posici\u00f3n p, y estrictamente decreciente a partir de ella (con 0 < p < N - 1). Por ejemplo, en el arreglo [1, 2, 3, 1, 0, -2] la posici\u00f3n del pico es p = 2. Se pide: implementar un algoritmo de divisi\u00f3n y conquista de orden O(log(n)) que encuentre la posici\u00f3n p del pico: `size_t posicion_pico(int v[], size_t ini, size_t fin);`. La funci\u00f3n ser\u00e1 invocar\u00e1 inicialmente como: posicion_pico(v, 0, n-1), y tiene como pre-condici\u00f3n que el arreglo tenga forma de pico.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 4,
		"file_id": 9865,
		"submission_status": "TIME_OUT",
		"last_submission_date": "2020-10-30T23:28:21Z",
		"date_created": "2020-10-04T17:18:46Z",
		"last_updated": "2020-10-04T18:58:37Z"
	},
	{
		"id": 381,
		"course_id": 11,
		"category_id": 75,
		"category_name": "C - Diccionarios, Hashing y Hash",
		"category_description": "",
		"name": "07 - TDA Multiconjunto",
		"description": "Implementar el TDA MultiConjunto. Este es un Conjunto que permite m\u00e1s de una aparici\u00f3n de un elemento, por lo que eliminando una aparici\u00f3n, el elemento puede seguir perteneciendo. Dicho TDA debe tener como primitivas:\n* `multiconj_t* multiconj_crear()`: crea un multiconjunto. \n* `bool multiconj_guardar(multiconj_t* multiconj, const char* elem)`: guarda un elemento en el multiconjunto. Devuelve true si se pudo guardar el elemento correctamente, false en caso contrario.\n* `bool multiconj_pertenece(const multiconj_t* multiconj, const char* elem)`: devuelve true si el elemento aparece al menos una vez en el conjunto.\n* `bool multiconj_borrar(multiconj_t* multiconj, const char* elem)`: elimina una aparici\u00f3n del elemento dentro del conjunto. Devuelve true si se elimin\u00f3 una aparici\u00f3n del elemento.\n* `void multiconj_destruir(multiconj_t* multiconj)` que libera la memoria asociada al TDA.  \n\nDar la estructura del TDA y la implementaci\u00f3n de las 4 primitivas marcadas, de forma tal que todas sean de tiempo constante.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 11308,
		"submission_status": "",
		"date_created": "2020-10-12T14:01:41Z",
		"last_updated": "2020-10-12T14:12:37Z"
	},
	{
		"id": 397,
		"course_id": 11,
		"category_id": 75,
		"category_name": "C - Diccionarios, Hashing y Hash",
		"category_description": "",
		"name": "15 - Cuckoo guardar",
		"description": "Dar una implementaci\u00f3n en C de c\u00f3mo podr\u00eda ser la primitiva `hash_guardar` para el caso de un hash cerrado con Cuckoo Hashing con dos funciones de hashing (suponer que se llaman `h1` y `h2`). Si la clave ya se encontraba en el hash simplemente devolver `false` (no es necesario hacer un reemplazo del dato).\nSe puede asumir que la estructura no se redimensiona: en caso de toparse con una situaci\u00f3n de un ciclo, debe devolver `false`. \nLa estructura del Hash es:\n\n```cpp\ntypedef struct hash {                   typedef struct campo_hash {\n    campo_hash_t* tabla;                    char* clave;\n    size_t cantidad;                        void* dato;\n    size_t tam_tabla;                       int num_fhash;\n} hash_t;                               } campo_hash_t;\n```",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 8,
		"file_id": 15688,
		"submission_status": "",
		"date_created": "2020-10-19T15:16:07Z",
		"last_updated": "2020-10-28T15:42:58Z"
	},
	{
		"id": 398,
		"course_id": 11,
		"category_id": 75,
		"category_name": "C - Diccionarios, Hashing y Hash",
		"category_description": "",
		"name": "16 - Diccionario con add_all",
		"description": "Se quiere implementar un TDA Diccionario con las siguientes primitivas: `obtener(x)` devuelve el valor de `x` en el diccionario; `insertar(x, y)` inserta en el diccionario la clave `x` con el valor `y` (entero); `borrar(x)` borra la entrada de `x`; `add(x, n)` le suma `n` al contenido de `x`; `add_all(m)` le suma `m` a todos los valores.\n\nProponer una implementaci\u00f3n donde **todas** las operaciones sean O(1). Justificar el orden de las operaciones.\n\n(En general un ejercicio as\u00ed podr\u00eda plantearse solo describiendo, pero para quienes quierran corroborarlo, en esta plataforma se encuentra definido el ejercicio en C)",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 16,
		"file_id": 15728,
		"submission_status": "",
		"date_created": "2020-10-19T17:04:38Z",
		"last_updated": "2020-10-28T16:04:29Z"
	},
	{
		"id": 429,
		"course_id": 11,
		"category_id": 76,
		"category_name": "D - \u00c1rboles Binarios, ABB, AVL, \u00c1rbol B",
		"category_description": "",
		"name": "01 - Altura",
		"description": "Dado un \u00e1rbol binario, escribir una primitiva recursiva que determine la altura del mismo. Indicar y justificar el orden de la primitiva.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 25403,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-28T22:03:20Z",
		"date_created": "2020-10-30T20:18:50Z",
		"last_updated": "2020-11-16T18:59:00Z"
	},
	{
		"id": 453,
		"course_id": 11,
		"category_id": 76,
		"category_name": "D - \u00c1rboles Binarios, ABB, AVL, \u00c1rbol B",
		"category_description": "",
		"name": "02 - Sumar todos",
		"description": "Implementar una primitiva que devuelva la suma de todos los datos (n\u00fameros) de un \u00e1rbol binario. \nIndicar y justificar el orden de la primitiva.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 1,
		"file_id": 40843,
		"submission_status": "SUCCESS",
		"last_submission_date": "2020-11-28T21:37:00Z",
		"date_created": "2020-11-15T22:49:26Z",
		"last_updated": "2020-11-15T22:59:25Z"
	},
	{
		"id": 454,
		"course_id": 11,
		"category_id": 76,
		"category_name": "D - \u00c1rboles Binarios, ABB, AVL, \u00c1rbol B",
		"category_description": "",
		"name": "04 - 2 hijos",
		"description": "Dado un \u00e1rbol binario, escriba una primitiva recursiva que cuente la cantidad de nodos que tienen exactamente dos hijos directos. \u00bfQu\u00e9 orden de complejidad tiene la funci\u00f3n implementada?",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 40851,
		"submission_status": "",
		"date_created": "2020-11-15T23:02:03Z",
		"last_updated": "2020-11-15T23:08:23Z"
	},
	{
		"id": 455,
		"course_id": 11,
		"category_id": 76,
		"category_name": "D - \u00c1rboles Binarios, ABB, AVL, \u00c1rbol B",
		"category_description": "",
		"name": "05 - Invertir",
		"description": "Escribir una primitiva con la firma `void ab_invertir(ab_t* arbol)` que invierta el \u00e1rbol binario pasado por par\u00e1metro, de manera tal que los hijos izquierdos de cada nodo se conviertan en hijos derechos.\n\nLa estructura arbol_t respeta la siguiente definici\u00f3n:\n\n```c\n    typedef struct ab {\n        struct ab* izq;\n        struct ab* der;\n        int dato;\n    } ab_t;\n```\n\nIndicar el orden de complejidad de la funci\u00f3n implementada.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 2,
		"file_id": 40861,
		"submission_status": "",
		"date_created": "2020-11-15T23:11:39Z",
		"last_updated": "2020-11-15T23:21:15Z"
	},
	{
		"id": 456,
		"course_id": 11,
		"category_id": 76,
		"category_name": "D - \u00c1rboles Binarios, ABB, AVL, \u00c1rbol B",
		"category_description": "",
		"name": "09 - Quiebres",
		"description": "Definimos como quiebre en un \u00e1rbol binario cuando ocurre que:\n* un hijo derecho tiene un solo hijo, y es el izquierdo\n* un hijo izquierdo tiene un solo hijo, y es el derecho\n\nImplementar una primitiva para el \u00e1rbol binario size_t ab_quiebres(const ab_t*) que, dado un \u00e1rbol binario, nos devuelva la cantidad de quiebres que tiene. La primitiva no debe modificar el \u00e1rbol.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 4,
		"file_id": 40879,
		"submission_status": "",
		"date_created": "2020-11-15T23:24:47Z",
		"last_updated": "2020-11-15T23:39:33Z"
	},
	{
		"id": 457,
		"course_id": 11,
		"category_id": 76,
		"category_name": "D - \u00c1rboles Binarios, ABB, AVL, \u00c1rbol B",
		"category_description": "",
		"name": "14 - Reconstrucci\u00f3n (particular)",
		"description": "Determinar c\u00f3mo es el \u00c1rbol cuyo pre order es EURMAONDVSZT, e in order es MRAUOZSVDNET.",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 4,
		"file_id": 41706,
		"submission_status": "",
		"date_created": "2020-11-16T18:50:41Z",
		"last_updated": "2020-11-23T22:40:57Z"
	},
	{
		"id": 476,
		"course_id": 11,
		"category_id": 76,
		"category_name": "D - \u00c1rboles Binarios, ABB, AVL, \u00c1rbol B",
		"category_description": "",
		"name": "12 - Reconstrucci\u00f3n (Funci\u00f3n)",
		"description": "Implementar una primitiva para el AB que reciba dos arreglos (o listas) de cadenas. El primer arreglo corresponde al preorder de un \u00e1rbol binario. El segundo al inorder del mismo \u00e1rbol (ambos arreglos tienen los mismos elementos, sin repetidos). La funci\u00f3n debe devolver un \u00e1rbol binario que tenga dicho preorder e inorder. Indicar y justificar el orden de la primitiva (tener cuidado con este punto). Considerar que la estructura del \u00e1rbol binario es:\n\n```cpp\n    typedef struct arbol {\n        struct arbol* izq;\n        struct arbol* der;\n        char* dato;\n    } ab_t;\n```\n",
		"language": "C",
		"is_iotested": false,
		"active": true,
		"deleted": false,
		"points": 8,
		"file_id": 47004,
		"submission_status": "",
		"date_created": "2020-11-23T22:33:55Z",
		"last_updated": "2020-11-23T22:40:43Z"
	}
]