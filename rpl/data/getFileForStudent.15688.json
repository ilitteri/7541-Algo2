{
	"hash_struct.h": "#ifndef STRUCT_HASH\n#define STRUCT_HASH\n\n#include <stddef.h>\n\ntypedef struct campo_hash {\n    char* clave;\n    void* dato;\n    int num_fhash;\n} campo_hash_t;\n\nstruct hash {                   \n    campo_hash_t* tabla;                   \n    size_t cantidad;                        \n    size_t tam_tabla;                       \n};\n\nsize_t h1(const char* clave, size_t largo);\nsize_t h2(const char* clave, size_t largo);\n\n#endif",
	"main.c": "#include <string.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"hash.h\"\n#include \"hash_struct.h\"\n\n\n/* crea una copia (memoria dinamica) de la cadena pasada por parametro */\nchar* strdup(const char* org) {\n    char* cpy = malloc(sizeof(char) * (strlen(org) + 1));\n    if (!cpy) return NULL;\n    strcpy(cpy, org);\n    return cpy;\n}\n\nbool hash_guardar(hash_t* hash, const char* clave, void* dato) {\n    // TODO\n    // Asumir que no hay que lidiar con potenciales redimensiones (en caso de tener que,\n    // devovler false)\n}",
	"hash.h": "#ifndef HASH_H\n#define HASH_H\n#include <stdbool.h> \n#include <stddef.h>\n\ntypedef struct hash hash_t;\n\n// A implementar\nbool hash_guardar(hash_t* hash, const char* clave, void* dato);\n\nhash_t* hash_crear();\n\nbool hash_pertenece(const hash_t* hash, const char* clave);\n\nvoid* hash_borrar(hash_t* hash, const char* clave);\n\nvoid* hash_obtener(const hash_t* hash, const char* clave);\n\nsize_t hash_cantidad(const hash_t* hash);\n\n// Se asume que Barbara se encarga de los datos, por simplicidad del ejercicio\nvoid hash_destruir(hash_t* hash);\n\n#endif",
	"files_metadata": "{\"main.c\":{\"display\":\"read_write\"},\"hash.h\":{\"display\":\"read\"},\"hash_struct.h\":{\"display\":\"read\"},\"hash.c\":{\"display\":\"hidden\"}}"
}