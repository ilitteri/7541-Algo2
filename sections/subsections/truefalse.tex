\documentclass[../../main.tex]{subfiles}

\begin{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{TRUE}. Si la función de comparación es la misma, no importa en que orden se inserten los elementos, al tener la misma función de comparación dejará los árboles en el mismo orden relativo para el recorrido inorder.
            \item \textbf{FALSE}. Si la función de comparación es diferente en dos ABBs y se insertan los mismos elementos en el mismo orden, no tendran el mismo inorder ya que, no guardará los elementos en el mismo orden relativo a causa de la diferencia entre funciones de comparación.
            \item \textbf{FALSE}. Dado este caso, si en uno de los ABBs inserto un nodo "A" primero, y en el otro inserto "B" primero, ya tengo un contraejemplo.
        \end{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{TRUE}. No hay problema en hacer esto, funcionaría igual que teniendo todos los pesos positivos.
            \item \textbf{TRUE}. Si ordeno de mayor a menor las aristas debería poder obtener un Árbol de Tendido Máximo.
            \item \textbf{FALSE}. Usando BFS o DFS, con el diccionario de padres puedo armar un árbol de tendido, y con complejidad $O(V+E)$ contra la complejidad $O(E\log(V))$ de Kruskal y Prim.
        \end{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{TRUE}. Como aclara que los pesos de las aristas son positivas, entonces al elevar dichos pesos al cuadrado el árbol de tendido mínimo es el mismo.
            \item \textbf{FALSE}. Contraejemplo: $G = (V, E)$, $V = \{A, B, C\}$, $E = \{(A, B, 1), (B, C, 1), (A, C, 2)\}$, $P_{A-C} = [A, C]$ en $G$, pero $P_{A-C} = [A, B, C]$ en $G^{2}$.
        \end{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{FALSE}. Que los valores sean discretos no es condición suficiente para utilizar Counting Sort, necesitaríamos saber además si el rango es acotado.
            \item \textbf{FALSE}. Una condición necesaria para que RadixSort funcione correctamente es que el algoritmo de ordenamiento auxiliar sea estable; la condición de ser in-place no es necesaria. Sólo se usa un algoritmo de ordenamiento auxiliar in-place cuando la memoria es algo a tener en cuenta. 
            \item \textbf{FALSE}. Las búsquedas siempre son $O(1)$ siempre que $k$ tenga el valor que tenga. La función de hashing va a variar la complejidad de la resolución de colisiones.
        \end{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{TRUE}. Es la forma en la que RadixSort ordena.
            \item \textbf{FALSE}. No es condición necesaria. Con que el algoritmo de ordenamiento auxiliar sea $O(n\log(n))$, ya que se puede despreciar el crecimiento logarítmico con valores no tan grandes de $B$ (cantidad de baldes) quedando $O(n)$.
            \item \textbf{}. Sólo se necesita revisar el camino de inserción.
        \end{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{TRUE}. Tenemos datos discretos en un rango acotado y conocido, siendo $k$ el número de sucesos y $n$ el rango (0 a 2021) entonces, Counting Sort es una buena opción, y la complejidad sería $O(n+k)$ pero $k << n \Rightarrow O(n)$. Además es estable.
            \item \textbf{FALSE}. RadixSort es un algoritmo de ordenamiento no comparativo. Para lograr una complejidad lineal $O(d\cdot (n+k))$, siendo $k$ el rango de los valores, $d$ la cantidad de "dígitos", y $n$ la cantidad de elementos. Si $d << \log(n) \wedge k << n \Rightarrow O(n)$.
            \item  
        \end{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{TRUE}. Si un grafo contiene un ciclo de \textit{n} vértices, o es un ciclo de \textit{n} vértices, si \textit{n} es par entonces si es bipartito porque puedo colorear los vértices del mismo con 2 colores, obteniendo dos conjuntos disjuntos de vértices de un mismo conjunto que no se relacionan entre sí. Usando como ejemplo Un ciclo de 2 vértices con aristas: $V = \{A, B\}, E = \{(A, B), (B, A)\}$ puedo usar un color para A y otro para B y obtener dos conjuntos disjuntos $color1 = \{A\}, color2 = \{B\}$. Usando como ejemplo un ciclo con \textit{n} impar: $V = \{A, B, C\}, E = \{(A, B), (A, C), (B, C)\}$, si coloreo con 2 colores alternando en el ciclo (para verificar
            que sea bipartito), me encuentro con que hay 2 vértices de un color relacionándose entre sí, cosa que no cumple con la definición de grafo bipartito.
            \item \textbf{TRUE}. En un árbol, todo vértice que tenga $2$ adyacentes es punto de articulación, porque, es el único vértice por el cuál se puede llegar a sus adyacentes (por definición de árbol).
            \item \textbf{FALSE}. En un grafo dirigido, puede no existir un camino de un vértice $V$ a de una componente fuertemente conexa hacia un vértice $W$ de otra componente fuertemente conexa, pero es no es cierto para todo par de vértices $V, W$.
            Contraejemplo: tengo una componente fuertemente conexa formada por vértices $A, B, C$ y otra componente fuertemente conexa formada por $E, F, G$, existe una arista $(B->E)$, gracias a esta arista, existe un camino desde un vértice $V$ de la primera componente conexa a cualquier vértice $V$ de la segunda componente conexa.
        \end{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{FALSE}. La arista de la habla la consigna, es una arista de retorno (no pertenece al grafo original). La proposición "arista que no existe en el grafo original implica que no se puede considerar para aumentar el flujo total" es falsa, porque, la arista de retorno se tiene en cuenta para reducir el flujo de ese camino para aumentar el flujo total.
            \item \textbf{TRUE}. El algoritmo de Bellman-Ford se puede aplicar en grafos (dirigidos como no dirigidos) que acepten pesos negativos, siempre y cuando no existan ciclos.
            \item \textbf{TRUE}. Utilizando cualquier algoritmo para obtener el árbol de tendido mínimo podemos obtenerlo de un grafo dirigido. No hay impedimento alguno.
        \end{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{FALSE}. Debe disminuir el flujo de la arista original, ya que si el algoritmo encontró una arista de estas características, se trata de una arista de retorno, entonces al actualizar el grafo, disminuirá el flujo de la arista original para aumentar el flujo total.
            \item \textbf{FALSE}. Si hay ciclos de más de dos vértices no hay problema para resolver la maximización de flujo. Y si hay ciclo de 2 vértices (aristas antiparalelas), el problema puede ser resuelto agregando un vértice entre ellos, para convertirlo en un ciclo de 3 vértices.
            \item \textbf{TRUE}. Es poco probable, pero puede suceder. No siempre es cierto ya que es posible que al armar el árbol de tendido mínimo me pierda algúna arista que signifique algún camino mínimo entre un vértice y otro. Ejemplo: $G = (V, E)$, $V = \{A, B, C, D\}$, $E = \{(A, B, 2), (A, D, 1), (B, C, 1), (C, D, 1)\}$ utilizando el Algoritmo de Dijkstra para calcular el camino mínimo desde $B$ hasta $A$ obtenemos $P_{B-A} = [B, A, 2]$. Un árbol de tendido mínimo sería $T = (V', E')$, $V' = V$, $E' = \{(A, D, 1), (D, C, 1), (C, B, 1))\}$.
        \end{enumerate}
    \item 
        \begin{enumerate}[label=\alph*)]
            \item \textbf{FALSE}. La primera proposición es verdadera, la segunda también, pero la tercera no. Esto es, cuando el algoritmo encuentra una arista que no pertenece al grafo original, la arista paralela debe disminuir el flujo, pero no para disminuir así el flujo total del grafo, sino para aumentarlo.
            \item \textbf{TRUE}. Se trata de la Red de Flujo trivial.
            \item \textbf{FALSE}. Contraejemplo: si el grafo tiene ciclos negativos, $\nexists$ camino mínimo.
        \end{enumerate}
\end{enumerate}

\clearpage