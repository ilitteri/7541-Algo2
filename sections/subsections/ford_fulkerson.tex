\documentclass[../../main.tex]{subfiles}

\subsubsection{Esquema General}
\lstinputlisting[language=Python]{algorithms/graphs/esquema_general_ff.py}

\subsubsection{Paso a paso}

\begin{itemize}
    \item Inicialmente defino para cada arista el flujo en 0.
    \item Como necesito trabajar con la red residual lo que hago es copiar el grafo original. Inicialmente el grafo residual es igual al grafo original porque en el grafo residual tenemos 2 tipos de aristas, las mismas al las del grafo original (en el mismo sentido), pero con la capacidad restante, y por el otro lado, tenemos las aristas de retorno, inicialmente en 0.
    \item Mientras haya un camino en la red residual (obtener camino, mediante cualquier algoritmo). Esto es lo que define que en realidad este algoritmo es en realidad un método, ya que no exige un algoritmo específico para encontrar este camino.
    \item Para actualizar el flujo, hay que obtener la capacidad que tengo que actualizar, y eso es el mínimo peso de todas las aristas, porque no puede pasar más del mínimo de unidades para la arista de dicho peso.
    \item Luego itero todos los vértices para obtener las aristas, fijándome si el vértice en la  posición \code{i} está entre los vértices del grafo original, ya que necesito saber si la arista con la que voy a trabajar es la arista original del grafo, o es la arista de retorno (del grafo residual).
    \item Para el primer caso, entonces queremos que vaya más flujo, entonces actualizamos el flujo de la arista actual, incrementándole el flujo mínimo obtenido anteriormente.
    \item Para el segundo caso, entonces para la arista de retorno (inversa), que si existe en el grafo, entonces tiene que volver flujo, para aumentar el flujo global, por lo tanto le disminuyo el flujo restándole el flujo mínimo obtenido anteriormente y actualizo en el sentido inverso.
    \item Para actualizar la red residual, lo primero que me tengo que fijar es cuánto es el peso anterior de lo que estamos actualizando, y si el peso anterior es igual a lo que  estoy usando, la saco directamente, sino le resto el valor. Y si no tiene la arista recíproca, la agrego en el valor actual, sino le cambio el peso.
    \item Al final, devuelvo el flujo.
\end{itemize}

\subsubsection{Algoritmo}
\lstinputlisting[language=Python]{algorithms/graphs/ford_fulkerson.py}

\subsubsection{Complejidad}
\begin{itemize}
    \item Todo depende de cómo elegimos buscar el camino.
    \item Puede demorar muchísimo, o ni siquiera converger.
    \item Teorema Edmonds-Karp: si se hace por BFS el algoritmo suempre funciona y es $O(V\cdot E^{2})$.
\end{itemize}

