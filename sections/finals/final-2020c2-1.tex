\documentclass[../../main.tex]{subfiles}

\subsubsection*{Consigna}

\begin{enumerate}
    \item Implementar en C una primita \code{lista\_t* lista\_slice(const lista\_t* original, size\_t inicio, size\_t fin)} que devuelva una \textbf{nueva} lista con los elementos de la original que se encuentran entre las posición \code{inicio} y \code{fin} (incluyendo el que se encuentra en la posición \code{inicio}, excluyendo el que se encuentra en la posición \code{fin}). Considerar la primera posición de la lista como la posición 0. En caso que \code{fin} sea menor o igual a \code{inicio}, devolver una lista vacía. En caso que \code{fin} sea mayor a la cantidad de elementos de la lista, simplemente agregar hasta el último. Si \code{inicio} es mayor a dicha última posición válida, devolver una lista vacía. Indicar y justificar la complejidad del algoritmo implementado.
    Ejemplos:
    \item Implementar un algoritmo que determine si un grafo no dirigido es un grafo disperso. Se considera que un grafo es disperso si tiene menos del $5\%$ de las aristas totales que puede llegar a tener. Indicar y justificar el orden del algoritmo, si el grafo se encuentra implementado con matriz de adyacencia.
    \item A un grafo pesado y no dirigido se le obtuvo un árbol de tendido mínimo. Sobre dicho árbol se quiere obtener caminos mínimos. Implementar un algoritmo que reciba dicho árbol y un vértice v y obtenga los caminos mínimos desde v hacia todos los demás vértices (sobre dicho grafo en forma de árbol, no el grafo original) en tiempo lineal de la cantidad de vértices y aristas. Justificar la complejidad del algoritmo implementado.
\end{enumerate}

\subsubsection*{Resolción}

\begin{enumerate}
    \item \lstinputlisting[language=C]{../../algorithms/finals/lista_slice.c}
    \item \lstinputlisting[language=Python]{../../algorithms/finals/grafo_disperso.py}
    \item \lstinputlisting[language=Python]{../../algorithms/finals/mst_shortest_paths.py}
\end{enumerate}