\documentclass[../../main.tex]{subfiles}

\subsubsection{Consigna}

\begin{enumerate}
    \item  Implementar una función que dados dos arreglos de n y m elementos, respectivamente, devuelva si ambos arreglos tienen todos sus elementos diferentes entre sí en $\Theta(n + m)$. Justificar el orden de la función implementada.
    \item Implementar un algoritmo que permita definir si un Grafo es un pseudo-bosque. Un Grafo es un pseudo-bosque si tiene a lo sumo un ciclo (considerar que el grafo podría no ser conexo). El algoritmo debe ejecutar de forma \textbf{lineal} tanto en la cantidad de vértices como de aristas. Justificar el orden del algoritmo implementado.
    \item Implementar un algoritmo que permita ordenar un arreglo de n números cuyos valores van de 0 a $n^{2}-1$ en tiempo \textbf{lineal}. \textit{Ayuda}: Para resolver este problema, no es conveniente ver los números necesariamente en base 10.
    \item Implementar en C una función \code{lista\_t* lista\_map(lista\_t*, void* (*f) (void*))} que, utilizando el \textbf{iterador interno} de la lista, permita crear \textbf{una nueva lista} con cada uno de los elementos de la recibida por parámetro, luego de haberles aplicado la función \code{f}. Pista: recordar que la primitiva \code{lista\_iterar} recibe un puntero \code{void* extra} que puede ser un puntero a cualquier cosa. Puede ser un puntero a una estructura que guarde, por ejemplo, un puntero a
    función, entre otras cosas.
\end{enumerate}

\subsubsection{Resolción}

\begin{enumerate}
    \item \lstinputlisting[language=C]{../../algorithms/finals/arreglo_ordenado_dyc.c}
    \item 
    \item 
    \item 
\end{enumerate}