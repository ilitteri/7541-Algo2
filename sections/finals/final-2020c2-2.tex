\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{fullpage}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath}  % For math
\usepackage{amssymb}  % For more math

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\title{Final}
\author{Ivan Litteri - 106223}
\date{2020c2-2}

\lstset{style=mystyle}
\begin{document}
\maketitle

\lstset{language=Python}

\section{Ejercicio 1}

\subsection{Consigna}

Responder las siguientes preguntas, justificando adecuadamente:

\begin{enumerate}[label=\alph*)]
    \item ¿Qué implica que un algoritmo de ordenamiento sea estable? ¿Es heapsort un algoritmo de ordenamiento estable?
    \item ¿Qué implica que un algoritmo de ordenamiento sea in-place? ¿Es heapsort un algoritmo de ordenamiento in-place?
    \item ¿Qué implica que un algoritmo de ordenamiento sea comparativo? ¿En qué condiciones puede utilizarse? ¿Es heapsort un algoritmo de ordenamiento comparativo?
\end{enumerate}

\subsection{Resolución}

\begin{enumerate}[label=\alph*)]
    \item Que un algoritmo de ordenamiento sea estable implica que los elementos del arreglo original mantienen su orden relativo en el arreglo final.
\end{enumerate}

\section{Ejercicio 2}

\subsection{Consigna}

En un árbol binario, dado un nodo con dos hijos, explicar por qué su prodecesor en el recorrido inorder no puede tener un hijo derecho, y que su sucesor (también. en el recorrido inorder) no puede tener un hijo izquierdo.

\subsection{Resolución}

\section{Ejercicio 3}

\subsection{Consigna}

Implementar un algoritmo que reciba un grafo dirigido y nos devuelva la cantidad de componentes débilmente conexas de este. Indicar y justificar la complejidad del algoritmo implementado.

\subsection{Resolución}

\section{Ejercicio 4}

\subsection{Consigna}

El servicio de correo electrónico de una oficina tiene casillas de correo. Cada casilla tiene un nombre de usuario (dueño de la casilla), e-mail, contraseña, y mensajes (clasificados en enviados y recibidos). Se pueden listar los mensajes recibidos
respetando el orden de llegada inverso (los últimos que llegaron primero), recibir nuevos mensajes y leer un mensaje indicado. También permite enviar mensajes, que se mostrarán de más recientes a más antiguos. Los mensajes de correo tienen los datos e-mail del emisor, contenido, y un estado (leído o no). Implementar las funciones:

\begin{enumerate}[label=\alph*)]
    \item `escribirUnMensaje` que dado un e-mail y contraseña, un destinatario y un texto, envie un mensaje.
    \item `verMisMensajes` que dado un e-mail y contraseña, su clasificación (enviados o recibidos) y una cantidad $n$, muestre los último $n$ mensajes enviados (o recibidos) por ese usuario de más reciente a más antiguo.
\end{enumerate}

Considerar estructuras necesarias para representar el servicio de correo electrónico de manera eficiente. Justificar la elección de la estructuras en función de la eficiencia de las operaciones.

\subsection{Resolución}

\section{Ejercicio 5}

\subsection{Consigna}

Tenemos un arreglo de tamaño $2n$ de la forma $\{C1, C2, C3, \dots, Cn, D1, D2, D3, \dots, Dn\}$, tal que la cantidad total de elementos del arreglo es potencia de 2 (por ende, $n$ tambien lo es). Implementar un algoritmo de División y Conquista que modifique el arreglo de tal forma que quede con la forma $\{C1, D1, C2, D2, C3, D3, \dots, Cn, Dn\}$ \textbf{sin utilizar espacio adicional} (obviando el utilizado por la recursividad). ¿Cuál es la complejidad del algoritmo?

\textit{Pista:} pensar primero cómo habría que hacer si el arreglo tuviera 4 elementos ($\{C1, C2, D1, D2\}$). Luego pensar a partir de allí el caso de 8 elementos, etc... para encontrar el patrón.

\subsection{Resolución}

\end{document}