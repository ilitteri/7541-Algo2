\documentclass[../main.tex]{subfiles}

Se define un ordenamiento comparativo a cualquier algoritmo de ordenamiento que determina el orden de ordenamiento comparando pares de elementos. Se basan en comparar elementos para poder ordenarlos. Se tiene como precondición que los datos a ordenar sean comparables. Tiene como cota mínima $\Omega(n\cdot log(n))$ por lo tanto no puede ser mejor que esto.

\subsection*{Merge Sort}
\lstinputlisting[language=Python]{algorithms/merge_sort.py}

\subsection*{Quick Sort}
\lstinputlisting[language=Python]{algorithms/quick_sort.py}

\subsection*{Selection Sort}
\lstinputlisting[language=Python]{algorithms/selection_sort.py}

\subsection*{Insertion Sort}
\lstinputlisting[language=Python]{algorithms/insertion_sort.py}

\subsection*{Bubble Sort}
\lstinputlisting[language=Python]{algorithms/bubble_sort.py}

\subsection*{Heapsort}

\lstinputlisting[language=Python]{algorithms/heapsort.py}

Este algoritmo de ordenamiento no es estable ya que cuando se aplica \textit{downheap}, como las cosas suben desde distintas ramas se pierde completamente el orden relativo; también si vamos a desencolar, el que estaba último pasa a estar primero y luego baja, y puede bajar por cualquier otra rama, etc. Es un algoritmo \textit{in-place}.

La complejidad de heapify es $O(log(n))$, armar el heap cuesta $O(n)$. Entonces su complejidad es $O(n\cdot log(n))$.